以下は、"[1,2],[3,4],[5,6]" という形式の文字列を受け取り、その転置を同じ形式で出力する Bash スクリプトです。引数で渡すか、標準入力から読み取ります。

保存例: transpose.sh

#!/usr/bin/env bash
input="${1:-$(cat)}"
# 先頭末尾の空白と改行を取り除く
input="$(printf "%s" "$input" | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

# awk でパースして転置を作る
printf "%s" "$input" | awk '
{
  s = $0
  # "],[" の前後に空白があっても行区切りにする
  gsub(/\]\s*,\s*\[/, "]\n[", s)
  nlines = split(s, lines, "\n")
  for (r = 1; r <= nlines; r++) {
    line = lines[r]
    # 各行の両端の角括弧を取り除く
    sub(/^\[/, "", line)
    sub(/\]$/, "", line)
    # カンマで分割
    m = split(line, fields, ",")
    if (m > cols) cols = m
    for (c = 1; c <= m; c++) {
      f = fields[c]
      # 前後の空白を削る
      sub(/^[ \t\r\n]+/, "", f)
      sub(/[ \t\r\n]+$/, "", f)
      a[r "," c] = f
    }
    rows = nlines
  }
}
END {
  # 転置出力: 各列を新しい行として出力（元の列数 = 転置後の行数）
  for (c = 1; c <= cols; c++) {
    printf "["
    for (r = 1; r <= rows; r++) {
      printf "%s", ((r "," c) in a ? a[r "," c] : "")
      if (r < rows) printf ","
    }
    printf "]"
    if (c < cols) printf ","
  }
  printf "\n"
}'

使い方例:
- 引数で渡す:
  ./transpose.sh '[1,2],[3,4],[5,6]'
  出力: [1,3,5],[2,4,6]

- 標準入力から:
  echo '[1,2],[3,4],[5,6]' | ./transpose.sh

注意:
- 要素間の空白（例: "[1, 2] , [3,4] "）があっても扱えます。
- 行・列のサイズが一致していない（不規則な行長）の場合、足りない要素は空文字として扱われます。必要なら挙動を変更します。